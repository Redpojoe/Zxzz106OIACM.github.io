<h1 id="doing-homework"><strong>Doing Homework</strong></h1>
<html>
<p align="right"> 来源：HDU_1074 </p>
</html>

<hr />

<h2 id="题目大意"><strong>题目大意</strong>：</h2>
<p>&lt;font color=brown&gt;有n个任务，每个任务有一个截止时间，超过截止时间一天，要扣一个分。
求如何安排任务，使得扣的分数最少。&lt;/font&gt;</p>

<p>Sample Input</p>

<p>2&lt;/br&gt;
3&lt;/br&gt;
Computer 3 3&lt;/br&gt;
English 20 1&lt;/br&gt;
Math 3 2&lt;/br&gt;
3&lt;/br&gt;
Computer 3 3&lt;/br&gt;
English 6 3&lt;/br&gt;
Math 6 3</p>

<p>Sample Output</p>

<p>2&lt;/br&gt;
Computer&lt;/br&gt;
Math&lt;/br&gt;
English&lt;/br&gt;
3&lt;/br&gt;
Computer&lt;/br&gt;
English&lt;/br&gt;
Math&lt;/br&gt;</p>

<h2 id="思路"><strong>思路：</strong></h2>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />本来用的是状压+dp，大部分数据也能过，杭电OJ上也AC。然而对拍出来有错（几乎所有状压dp的代码都是错的，并且错处几乎一样）。这里附上此代码：
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node {
  string name;
  int en,co;
} a[20];
int bin[(1&lt;&lt;15)+5],dp[20][(1&lt;&lt;15)+5],fa[20][(1&lt;&lt;15)+5];
void print(int x,int f) {
  if(fa[x][f]==x) {
      cout&lt;&lt;a[x].name&lt;&lt;endl;
      return;
  }
  print(fa[x][f],f^(1&lt;&lt;(x-1)));
  cout&lt;&lt;a[x].name&lt;&lt;endl;
}
int main() {
  for(int i=0; i&lt;=15; i++)bin[1&lt;&lt;i]=i+1;
  int T;
  scanf("%d",&amp;T);
  while(T--) {
      for(int i=1; i&lt;=15; i++)
          for(int j=0; j&lt;(1&lt;&lt;15); j++)fa[i][j]=i;
      int n;
      scanf("%d",&amp;n);
      for(int i=1; i&lt;=n; i++) {
          cin&gt;&gt;a[i].name;
          scanf("%d%d",&amp;a[i].en,&amp;a[i].co);
      }
      for(int i=1; i&lt;=n; i++)
          for(int j=0; j&lt;(1&lt;&lt;n); j++)dp[i][j]=1e9;
      for(int i=1; i&lt;=n; i++)dp[i][1&lt;&lt;(i-1)]=max(0,a[i].co-a[i].en);
      for(int j=0; j&lt;(1&lt;&lt;n); j++) {
          for(int i=1; i&lt;=n; i++) {
              for(int k=1; k&lt;=n; k++) {
                  if(((1&lt;&lt;(k-1))&amp;j)!=0||((1&lt;&lt;(i-1)&amp;j))==0||i==k)continue;
                  int t=j,cnt=0;
                  while(t) {
                      int p=t&amp;-t;
                      t-=p;
                      cnt+=a[bin[p]].co;
                  }
                  if(dp[k][j|(1&lt;&lt;(k-1))]&gt;dp[i][j]+max(0,cnt+a[k].co-a[k].en)) {
                      dp[k][j|(1&lt;&lt;(k-1))]=dp[i][j]+max(0,cnt+a[k].co-a[k].en);
                      fa[k][j|(1&lt;&lt;(k-1))]=i;
                  } else if(dp[k][j|(1&lt;&lt;(k-1))]==dp[i][j]+max(0,cnt+a[k].co-a[k].en)) {
                      fa[k][j|(1&lt;&lt;(k-1))]=max(fa[k][j|(1&lt;&lt;(k-1))],i);
                  }
              }
          }
      }
      int v,mi=1e9;
      for(int i=1; i&lt;=n; i++) {
          if(dp[i][(1&lt;&lt;n)-1]&lt;mi)mi=dp[v=i][(1&lt;&lt;n)-1];
          else if(dp[i][(1&lt;&lt;n)-1]==mi)v=max(v,i);
      }
      printf("%d\n",mi);
      print(v,(1&lt;&lt;n)-1);
  }
  return 0;
}
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h2 id="以下是正解">以下是正解：</h2>

<p>  用dfs进行搜索，对于每种选择方案，枚举还未被选择的任务序号，查找最小的扣分数，记录，并即使更新当前状态下的下一步选择。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;bits/stdc++.h&gt;
#define oo 0x7f7f7f7f
using namespace std;
int n,en[20],co[20],bin[(1&lt;&lt;15)+5],mx,u[(1&lt;&lt;15)+5],cho[(1&lt;&lt;15)+5],dp[(1&lt;&lt;15)+5];
char name[20][105];
int dfs(int x) {
	if(dp[x]!=oo)return dp[x];
	int ans=oo,as=0;
	for(int i=0; i&lt;n; i++) {
		if((x&amp;(1&lt;&lt;i)))continue;
		int res=dfs(x|(1&lt;&lt;i));
		if(u[x]+co[i]&gt;en[i])
			res+=u[x]+co[i]-en[i];
		if(ans&gt;res)as=i,ans=res;//由于输入数据已按字典序排好，所以不用考虑ans==res时是否需要换as 
		 
	}
	cho[x]=as;
	return dp[x]=ans;
}
int main() {
	for(int i=0; i&lt;=15; i++)bin[1&lt;&lt;i]=i;
	int T;
	scanf("%d",&amp;T);
	while(T--) {
		scanf("%d",&amp;n);
		for(int i=0; i&lt;n; i++)scanf("%s%d%d",name[i],&amp;en[i],&amp;co[i]);
		mx=(1&lt;&lt;n)-1;
		for(int i=1; i&lt;=mx; i++)u[i]=u[i&amp;i-1]+co[bin[i&amp;-i]];//预处理每种情况的花费；
		//i&amp;i-1即去掉i二进制的最后一位1 
		memset(dp,oo,sizeof(dp));
		dp[mx]=0;
		printf("%d\n",dfs(0));
		int now=0;
		while(now!=mx){
			printf("%s\n",name[cho[now]]);
			now|=(1&lt;&lt;cho[now]);
		}
	}
	return 0;
}
</code></pre></div></div>

