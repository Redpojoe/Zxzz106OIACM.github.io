---
layout: default
title: "物流运输"
date: 2018-07-16
category: ACpjy's Note
---

# **物流运输**
#### 来源：ZJOI2006

---
## 题目：
**物流公司要把一批货物从码头A运到码头B。由于货物量比较大，需要n天才能运完。货物运输过程中一般要转
停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种
因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是
修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个n天的运输计划，使得总成本
尽可能地小。**

### ++Input：++　

**第一行是四个整数n（1<=n<=100）、m（1<=m<=20）、K和e。n表示货物运输所需天数，m表示码头总数，K表示
每次修改运输路线所需成本。接下来e行每行是一条航线描述，包括了三个整数，依次表示航线连接的两个码头编
号以及航线长度（>0）。其中码头A编号为1，码头B编号为m。单位长度的运输费用为1。航线是双向的。再接下来
一行是一个整数d，后面的d行每行是三个整数P（ 1 < P < m）、a、b（1< = a < = b < = n）。表示编号为P的码
头从第a天到第b天无法装卸货物（含头尾）。同一个码头有可能在多个时间段内不可用。但任何时间都存在至少一
条从码头A到码头B的运输路线。**

### ++Output：++

**一个整数表示最小的总成本。总成本=n天运输路线长度之和+K乘以改变运输路线的次数。**


++==**Sample Input**==++

5 5 10 8  
1 2 1  
1 3 3  
1 4 2  
2 3 2  
2 4 4  
3 4 1  
3 5 2  
4 5 2  
4  
2 2 3  
3 1 1            
3 3 3  
4 4 5  

++==**Sample Output**==++  
32

###### > 样例解释：前三天走1-4-5，后两天走1-3-5，这样总成本为(2+2)*3+(3+2)*2+10=32。

---

## 思路：
 - [ ] **乍一看题目很复杂，不愧是省赛题。题目大概是什么意思呢？就是有n天，每天要走一条航线运送货物，这天需要花费航线的长度。如果遇到原定的航线中有一个港口关闭了，需要改变路线，改一次要k的花费，求这n天的最少花费。**
 - [ ] **像这种有时间线、求最小代价的题目，绝大部分就是dp题。同时，这是一道显而易见的图论题，需要求最短路。**
 - [ ] **此题有状压dp等一大堆写法，毕竟是个比较杂的题目，此处先介绍一种代码量较小的算法：**

# 弗洛伊德（`$floyd$`）+`$dp$`
**其实本题的核心思维就是最短路+dp，只不过此处用了代码量较小的弗洛伊德算法。**

- [ ] **那么怎么做呢？将每个时间段内的最少花费求出来，对于在这一时间段封闭的点，floyd就不经过它。然后以时间为阶段，dp到第几天的最小花费。**
- [ ] **最多100天，也就是最多有100^2个时间段，每个时间段最多要floyd25个点，要25的3次方。**
```math
O = 100^2*25^3 = 156250000
```
- [ ] **不会超吧。**


## AC代码：

---

<font size="5">

```C++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,m,k,e,d,mp[25][25];
ll dp[105],r[105][105],dis[25][25];
bool mark[25],stop[25][105];
void solve(int be,int en){
	memset(mark,0,sizeof(mark));
	for(int i=1;i<=m;i++)
	for(int j=1;j<=m;j++)dis[i][j]=1ll*mp[i][j];
	for(int i=2;i<m;i++)
	for(int j=be;j<=en;j++)if(stop[i][j]){
		mark[i]=1;
		break;
	}
	for(int q=1;q<=m;q++){
		if(mark[q])continue;
		for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++)
			dis[i][j]=min(dis[i][j],dis[i][q]+dis[q][j]);
	}
	r[be][en]=dis[1][m];
}
int main() {
	for(int i=1; i<=20; i++)
		for(int j=1; j<=20; j++)mp[i][j]=1e18;
	for(int i=1;i<=100;i++)dp[i]=1e18;
	scanf("%d%d%d%d",&n,&m,&k,&e);
	for(int i=1; i<=e; i++) {
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		mp[a][b]=min(mp[a][b],c);
		mp[b][a]=min(mp[b][a],c);
	}
	scanf("%d",&d);
	for(int i=1; i<=d; i++) {
		int p,a,b;
		scanf("%d%d%d",&p,&a,&b);
		for(int j=a; j<=b; j++)stop[p][j]=1;
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)solve(i,j);
	for(int i=1;i<=n;i++){
		dp[i]=r[1][i]*i;
		for(int j=0;j<i;j++)dp[i]=min(dp[i],dp[j]+k+r[j+1][i]*(i-j));
	}
	//for(int i=1;i<=n;i++)printf("%d ",dp[i]);
	printf("%lld",dp[n]);
	return 0;
}
```

</font>