---
layout: default
title: "汽油补给"
date: 2018-07-16
category: 聪聪的笔记
---

# 汽油补给

##### <p align="right">来源:51Nod-1288<p>

## 题目：
有（N+1）个城市，0是起点N是终点，开车从0 -> 1 - > 2...... -> N，车每走1个单位距离消耗1个单位的汽油，油箱的容量是T。给出每个城市到下一个城市的距离D，以及当地的油价P，求走完整个旅途最少的花费。如果无法从起点到达终点输出-1。
例如D = {10, 9, 8}, P = {2, 1, 3}，T = 15，最小花费为41，在0加上10个单位的汽油，在1加满15个单位的汽油，在2加2个单位的汽油，走到终点时恰好用完所有汽油，花费为10 * 2 + 15 * 1 + 2 * 3 = 41。

==**Input**==

第1行：2个数N, T中间用空格分隔，N + 1为城市的数量，T为油箱的容量(2 <= N <= 100000, 1 <= T <= 10^9)。 
第2至N + 1行：每行2个数Di, Pi，中间用空格分隔，分别表示到下一个城市的距离和当地的油价（1 <= Di, Pi <= 1000000)。

**==Output==**

输出走完整个旅程的最小花费，如果无法从起点到达终点输出-1。

==++**Sample Input**++==

3 15  
10 2  
9 1  
8 3  

==++**Sample Output**++==

41

---
## 思路：
- ##### 我们可以这样考虑：现在当前的地方把油加满，到下一个点后，如果油花不完并且下一个地方的油更便宜，就把上一个点的多的油还回去，买这里的油。
- #### 对于情境模拟题，要搞清楚应该如何决策。
- ##### 那么应该如何实现呢？可以发现，如果到了一个更便宜的站点，那么就将之前所有更贵的多买的油全换回去；如果有一个点的油不得不买，那ans就加上不得不买的花费，这一部分不得不买的油不在被更新，这可以想到单调队列。这也有一点回撤贪心的想法。

## AC代码：

```
#include<stdio.h>
#define ll long long
const int M=100005;
using namespace std;
struct node {
	int co,di;
} Q[M];
int main() {
	int n,t,l=0,r=0,v=0;
	ll ans=0;
	scanf("%d%d",&n,&t);
	for(int i=1; i<=n; i++) {
		int d,p;
		scanf("%d%d",&d,&p);
		if(d>t) {
			printf("-1");
			return 0;
		}
		while(l<r&&p<=Q[r].co&&v>=Q[r].di)v-=Q[r].di,r--;
		Q[++r]=(node) {
			p,t-v
		};
		v=t;
		v-=d;
		while(d) {
			for(int i=l+1; i<=r; i++)
				if(d>=Q[i].di) {
					d-=Q[i].di;
					ans+=1ll*Q[i].co*Q[i].di;
					l++;
				} else {
					ans+=1ll*Q[i].co*d;
					Q[i].di-=d;
					d=0;
				}
		}
	}
	printf("%lld",ans);
	return 0;
}
```
