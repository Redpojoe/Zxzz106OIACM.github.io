---
layout: default
title: "三等分"
date: 2018-07-16
category: ACpjy's Note
---
# 三等分：
##### 来源：hihocoder-1480

---
## 题目：

**小Hi最近参加了一场比赛，这场比赛中小Hi被要求将一棵树拆成3份，使得每一份中所有节点的权值和相等。**

**比赛结束后，小Hi发现虽然大家得到的树几乎一模一样，但是每个人的方法都有所不同。于是小Hi希望知道，对于一棵给定的有根树，在选取其中2个非根节点并将它们与它们的父亲节点分开后，所形成的三棵子树的节点权值之和能够两两相等的方案有多少种。**

 **两种方案被看做不同的方案，当且仅当形成方案的2个节点不完全相同。**
 
###### **`$Input$`**
**每个输入文件包含多组输入，在输入的第一行为一个整数T，表示数据的组数。**

**每组输入的第一行为一个整数N，表示给出的这棵树的节点数。**

**接下来N行，依次描述结点1~N，其中第i行为两个整数Vi和Pi，分别描述这个节点的权值和其父亲节点的编号。**

**父亲节点编号为0的结点为这棵树的根节点。**

**对于30%的数据，满足3<=N<=100**

**对于100%的数据，满足3<=N<=100000, |Vi|<=100, T<=10**

###### `$Output$`
**对于每组输入，输出一行Ans，表示方案的数量。**

==++**Sample Input**++==

2  
3  
1 0  
1 1  
1 2  
4  
1 0  
1 1  
1 2  
1 3  

==++**Sample Output**++==

1  
0  
---

## 思路：
> - ##### 这是一道初步的树形dp题，dp的顺序变为由根节点向各个子节点遍历。
> - ##### 因为把一棵树等分成3分，我们就要找到一类节点，以它们为根节点的子树的权值和是整个树的权值和的三分之一或三分之二，我们暂时称它们为三分之一节点和三分之二节点。树的遍历可以帮我们求出所有子树的权值和，进而找到这些三分之一和三分之二点。
> - ##### 接下来就是问题所在了：并不是每两个三分之一节点都可以满足要求。我们现在剖析一下这些节点。
> - ##### 对于每个三分之二节点，以它为根的子树上的所有三分之一节点都可以与这个三分之二节点满足要求，ans++。但对于以某个三分之一节点为根的子树上的三分之一节点（出现这种情况的原因是节点权值可以小于等于0），它们两个不可以符合要求。所以在遍历时，若发现某个节点是三分之一节点，那就让ans减去它子树中的所有三分之一节点的个数，（因为会对于这个根节点会多算这么多次，提前减去）。
> - ##### 最后再用组合数求出所有三分之一节点两两配对的方案数，即可求得答案。
---
## AC代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int v[100005],p[100005],res[100005],sum,root;
ll ans,cnt[100005];
vector<int>A[100005];
void dfs(int x) {
	res[x]=v[x];
	for(int i=0; i<A[x].size(); i++) {
		int y=A[x][i];
		dfs(y);
		res[x]+=res[y];
		cnt[x]+=cnt[y];
	}
	if(x==root)return;
	if(res[x]==2*sum)ans+=cnt[x];
	if(res[x]==sum)ans-=cnt[x]++;
}
int main() {
	int T;
	scanf("%d",&T);
	while(T--) {
		int n,be;
		sum=0,ans=0;
		scanf("%d",&n);
		for(int i=1; i<=n; i++) {
			A[i].clear();
			cnt[i]=res[i]=0;
		}
		for(int i=1; i<=n; i++) {
			scanf("%d%d",&v[i],&p[i]);
			A[p[i]].push_back(i);
			sum+=v[i];
			if(p[i]==0)root=i;
		}
		if(sum%3)printf("0\n");
		else {
			sum/=3;
			dfs(root);
			ans+=cnt[root]*(cnt[root]-1)/2;
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```
