---
layout: default
title: "部落信号"
date: 2018-07-16
category: ACpjy's Note
---

## 部落信号
#### <p align="right">来源：51Nod-1482<p>
---
## 题目：
众所周知，如今的波兰在很久以前住着很多部落。他们的首都被n座山所环绕，形成一个圆圈。在每一座山上有一个哨兵，他日夜观察附近的山。
如果有任何危险，哨兵会在山上放一把火。如果在连接两座山的圆弧上的任何一座山都不高于这两座山，那么这两座山上的哨兵能相互看到对方。由于任意两座山都有两条不同的圆弧连接他们，所以如果这两条圆弧中的任意一条能满足以上条件，那么信号就可见。例如，对于任意两个相邻的哨兵，他们的信号都是互相可见的。
一个侦查系统的重要特征是能看见对方信号的哨兵的对数。你需要根据给出的山的高度得到这些哨兵的对数。

**Input**  
输入的第一行是一个整数 n (3 ≤ n ≤ 10^6)，n——首都四周的山的总数。第二行包含n个整数——顺时针方向的山的高度。所有的山的高度都是整数并且在1和1e9之间。  

**Output**  
输出信号互相可见的哨兵的对数。

#### 题目大意：
##### n个数 ai围成一个环，两个数能看到当且仅当两条路径中一条满足所有数都小于等于这两个数 问有多少对数能互相看见?

++==**Sample Input**==++

5 1 2 4 5 3

++==**Sample Output**==++

7

---

## 思路：
- ##### 其实仔细观察题目可以发现，对于一座山，在顺时针上，可以和他互相看见的山是单调递增的；逆时针亦是如此。
- ##### 所以我们可以联想到单调栈。首先破环成链：因为比最高的山要矮的山肯定不能通过最高的山互望，而和最高的一样高的又可以通过另一个方向互望，所以选择最高的山作为破坏点。
- ##### 再然后对于每座山，找出他作为最高的山的范围。如果除了最高的山以外，还有一座山比这座山更高，那ans就++；如果有山与此山一样高，那一样高的山能看到的山这座山也能，而且当前的山还能与和他一样高的山形成一个新的组合，所以s[i]=s[stk[top]]+1.
- ##### 最后再找一找那座最高的山可以和谁形成组合就可以了。
- ##### 至于为什么这样是正确的呢？首先，本题不允许重复。并且一座山至少有两座山(相邻的两座)可以互望，所以不妨将所有山的与别的山的互望平均分配。
---
## AC代码：

```cpp
#include<stdio.h>
#define ll long long
using namespace std;
const int M=1000005;
int h[M],stk[M],l[M],r[M],s[M];
bool mark[M];
int main(){
	int n,mxi=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&h[i]);
		if(h[i]>h[mxi])mxi=i;
	}
	int top=0;
	for(int i=mxi;i<=n;i++)stk[++top]=h[i];
	for(int i=1;i<mxi;i++)stk[++top]=h[i];
	for(int i=1;i<=top;i++)h[i]=stk[i];
	h[0]=h[n+1]=1e9+7;
	stk[top=1]=0;
	for(int i=2;i<=n;i++){
		while(h[stk[top]]<=h[i])top--;
		l[i]=stk[top];
		stk[++top]=i;
	}
	stk[top=1]=n+1;
	for(int i=n;i>=2;i--){
		while(h[stk[top]]<=h[i]){
			if(h[stk[top]]==h[i])s[i]=s[stk[top]]+1;
			top--;
		}
		r[i]=stk[top];
		stk[++top]=i;
	}
	ll ans=0;
	int mx=0;
	for(int i=2;i<=n;i++){
		if(h[i]>=mx){
			ans++;
			mx=h[i];
			mark[i]=1;
		}
		if(l[i]>0)ans++;
		if(r[i]<=n)ans++;
		ans+=s[i];
	}
	mx=0;
	for(int i=n;i>=2;i--){
		if(h[i]>=mx){
			if(!mark[i])ans++;
			mx=h[i];
		}
	}
	printf("%lld",ans);
	return 0;
}
```
